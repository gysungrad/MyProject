/**
 * @file adaptmesh.cc
 * Header file for class adaptmesh
 */

#include "adaptMesh.h"
#include "processor.h"
#include "odtParam.h"
#include <fstream>
#include <cmath>            
#include <cstdlib>            
#include <algorithm>            

using namespace std;

extern processor proc;

///////////////////////////////////////////////////////////////////////////////

/** Constructor function.
 *
 *  @param anyll input: set anyline pointer with.
 *  @param odtPP input: set odtParam pointer with.
 *  @param phiP  input: set vector pointer with.
 */

adaptMesh::adaptMesh(anyline *anyll, odtParam *odtPP, vector<vector<double> *> phiP) {

    anyl = anyll;
    odtP = odtPP;

    ngrd  = anyl->ngrd;
    ngrdf = anyl->ngrdf;

    iLower = 0;
    iUpper = ngrd-1;
    posLower = anyl->posf[iLower];
    posUpper = anyl->posf[iUpper+1];

    setDxArray();
    splitLargeCells();

    phi = phiP[0];
    bdy = &(anyl->phase);
   

}

///////////////////////////////////////////////////////////////////////////////

/** User interface to the mesh adapter.
 * Makes several passes over the grid applying different criteria in succession.
 *
 * @param iLowerDummy input: lower cell to adapt from (approx).
 * @param iUpperDummy input: upper cell to adapt to (approx).
 */
void adaptMesh::adaptGrid(int iLowerDummy, int iUpperDummy) {

    if(iLowerDummy == iUpperDummy)
        return;

    //---------- reset values

    ngrd     = anyl->ngrd;
    ngrdf    = anyl->ngrdf;
    iLower   = iLowerDummy;
    iUpper   = iUpperDummy;
    posLower = anyl->posf[iLower];
    posUpper = anyl->posf[iUpper+1];

    setDxArray();

    //---------- adapt the grid

    //anyl->outputProperties(proc.dataDir+"adpt_0.dat");     // uncomment extern processor proc; at top

    mergeSmallCells();          

    //anyl->outputProperties(proc.dataDir+"adpt_1.dat");

    mergeSmallGradsCurvs(); 

    //anyl->outputProperties(proc.dataDir+"adpt_2.dat");
  
    splitHighGradsCurvs();   

    //anyl->outputProperties(proc.dataDir+"adpt_3.dat");

    impose2point5rule();             // do last to clean up the mess

    //anyl->outputProperties(proc.dataDir+"adpt_4.dat");
}

///////////////////////////////////////////////////////////////////////////////

/** Cells that are too small are merged with their neighbors.
 *  Cells here are marked simply as whether they are small or not.
 *  The subsequent merging is with either neighbor.  Elsewhere marked
 *  cells are to be merged with the right neighbor.
 *  Small cells are usually (always) generated by triplet map events that
 *  compress the grid.
 *  Mark the small cells by filling mark (member) with indicies in grid
 *  Merge the small cells in size order.  That is, initial size order, not
 *  accounting for intermediate changes.  This eliminates directional bias too.
 *  So rearrange the small cell indicies into sorted order, scMark (local).
 *  Then loop over each small cell till big enough, merging with its smaller neighbor.
 *  The smaller neighbor may or may not be a small cell.  When merge cells,
 *  need to decrement larger indicies (cells) in the scMark array, and delete cells
 *  from scMark if a small cell is merged with another.
 *  No special treatment for periodic boundaries.  Periodic is the same as nonperiodic.
 *  The periodic boundary position is maintained, and no merging occurs across 
 *  a periodic boundary (which would move the boundary from zero).                               
 */
void adaptMesh::mergeSmallCells() {

    int i, j;

    //---------- mark the small cells

    mark.clear();
//    if(!odtP->Lperiodic) 
//        for(i=iLower; i<=iUpper; i++)    
//            if(dx[i] < odtP->dxmin)
//                mark.push_back(i);
//    else 
        for(i=0; i<=ngrd-1; i++)            // periodic: the combustion line can have
            if(dx[i] < odtP->dxmin)         // small cells outside the adapt range.
                mark.push_back(i);          // just check the whole domain

    //---------- sort the small cells to remove any directional bias
    
    vector<int> ind(mark.size());           // index map for the sort
    for(i=0; i<(int)ind.size(); i++)        // sort "ind" using dx as sort condition
        ind[i]=i;
    sort(ind.begin(), ind.end(), *this);    // *this invokes the functor "operator()"
    vector<int> scMark(mark.size());        // reorder the mark array
    for(i=0; i<(int)ind.size(); i++)        // could just use mark[ind[i]],
        scMark[i] = mark[ind[i]];           // but reorder for simplicity 


    //---------- merge small cells
    
    int isc;                                // small cell index
    int iSmallerNB;                         // smaller of 2 neighbors
    int iend = scMark.size();               // may change as merge cells
    bool LcellDone;                         // flag to repeat small cells till big

    //---------------------------------

    for(i=0; i<iend; i++) {                 // loop over small cells
        
        isc = scMark[i];
        LcellDone = false;     

        //---------------------------------

        while(!LcellDone) {                 // keep going till small cell is done

            if(isc == 0)
                iSmallerNB = 1;
            else if(isc == ngrd-1)
                iSmallerNB = ngrd-2;
            else {
                iSmallerNB = (dx[isc-1] <= dx[isc+1]) ? isc-1 : isc+1;

                // For a location with two neighbors, if the phase of the chosen               
                // neighbor is different, instead choose the other neighbor.                   

                if (fabs((*bdy)[isc]-(*bdy)[iSmallerNB]) > 0.01)                               
                    iSmallerNB = 2 * isc - iSmallerNB;                                         
            }                                                                              

            // If phases are different, both cells are assigned the                                
            // 'dominant' (index 0) phase.  Merging can then occur.                            
            // This procedure is a placeholder for a user-specified                            
            // procedure for managing dissimilar phases when cells                             
            // are small enough so that merging is necesary.                                  

            if ((*bdy)[isc]-(*bdy)[iSmallerNB] > 0.01) {    
                anyl->copyProps(iSmallerNB, isc);                             
                (*bdy)[isc] = 0.;                                                              
                (*bdy)[iSmallerNB] = 0.;                                                       
            }                                                                                  

            if ((*bdy)[isc]-(*bdy)[iSmallerNB] <  -0.01) {    
                anyl->copyProps(isc, iSmallerNB);                             
                (*bdy)[isc] = 0.;                                                              
                (*bdy)[iSmallerNB] = 0.;                                                       
            }                                                                                  

            if(dx[iSmallerNB] + dx[isc] >= odtP->dxmin) 
                LcellDone = true;           // if new cell big enough then done 

            //---------------------------------

            if(iSmallerNB > isc) {

                // merge cells

                merge2cells(isc);

                // delete cell iSmallerNB from scMark array (if present)
                // and decrement all cells > isc in scMark

                for(j=i+1; j<iend; j++) 
                    if(scMark[j] > isc)
                        scMark[j]--;
                for(j=i+1; j<iend; j++) 
                    if(scMark[j]==isc){
                        scMark.erase(scMark.begin()+j);
                        iend--;
                        break;
                    }

            }         // if(iSmallerNB > isc)

            //---------------------------------

            else {    

                // merge cells

                merge2cells(isc-1);
                 
                // decrement isc and scMark[i] which is isc
                // delete cell isc-1 in scMark if present
                // and decrement 

                scMark[i]--;
                isc--;

                for(j=i+1; j<iend; j++) 
                    if(scMark[j] > isc)
                        scMark[j]--;
                for(j=i+1; j<iend; j++) 
                    if(scMark[j]==isc){
                        scMark.erase(scMark.begin()+j);
                        iend--;
                        break;
                    }


            }     // else (i.e., iSmallerNB < isc)
            //---------------------------------
        }         // end while
        //---------------------------------
    }             // end loop over small cells

    //---------- update the eddy regions

    iLower = anyl->linePositionToIndex(posLower, true);
    iUpper = anyl->linePositionToIndex(posUpper, false);

}                 // end function

///////////////////////////////////////////////////////////////////////////////

/** Merge cell imrg with imrg+1.
 *
 * @param imrg input: merge imrg with imrg+1 
 */
void adaptMesh::merge2cells(int imrg) {        

    anyl->merge2cells(imrg);
    int ip  = imrg+1;

    //anyl->adptVar[imrg] = ( anyl->adptVar[imrg]*dx[imrg] + 
    //anyl->adptVar[ip]  *dx[ip]     )/(dx[imrg]+dx[ip]);
    //anyl->adptVar.erase(anyl->adptVar.begin()+ip);

    dx[imrg] = dx[imrg] + dx[ip];
    dx.erase( dx.begin() + ip );


    ngrdf--;
    ngrd--;

}

///////////////////////////////////////////////////////////////////////////////

/** @param imrg input: merge imrg with next cells.
 *  @param ncells input: number of cells to merge.
 */

void adaptMesh::mergeSeveralCells(int imrg, int ncells) {        

    anyl->mergeSeveralCells(imrg, ncells);  

    int i1 = imrg+1;
    int i2 = imrg+ncells;
    //anyl->adptVar[imrg] *= dx[imrg];
    for(int i=i1; i<i2; i++){
        dx[imrg] += dx[i];
        //anyl->adptVar[imrg]+=anyl->adptVar[i]*dx[i];
    }
    dx.erase( dx.begin()+i1, dx.begin()+i2 );

    //anyl->adptVar[imrg] /= dx[imrg];
    //anyl->adptVar.erase(anyl->adptVar.begin()+i1,anyl->adptVar.begin()+i2);

    ngrdf -= ncells-1;
    ngrd  -= ncells-1;

}

///////////////////////////////////////////////////////////////////////////////

/** Merge cells with a small difference in phi values AND small differences in curvature values.  
 *  Note, grads really means delta of phi, not a real gradient.
 *  Curvature likewise: at each point the theta array holds the slope of the profile
 *  as an angle in radians.  "Curvature" is the difference in theta values (not
 *  divided by dx).  The grad is nice for steep, flat regions, but bad for
 *  peaks and troughs.  The curv is nice for peaks/troughs but not for flat steeps.
 *  Grad/Curv are as in Oppdif.
 *  odtP has a fraction of max phi as the threshold, this is computed in 
 *  setLargeSmallDphi.  
 *  phi should be a member of odtline so it shares the same grid and is 
 *  updated with merging and splitting operations
 *  A member grad array is filled for all cells on domain
 *  A memeber mark array marks cells to be merged.  
 *  E.g., x  x  x  M  M  M  x  M  x  x  x  x  M  M  x  x  x
 *        0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16
 *  The mark array would be (3 4 5 7 12 13)
 *  Mx implies M and x will be merged
 *  Split up into merge groups consisting of the start position, and number.
 *  Traverse the groups backwards so that merging doesn't change the index numbering
 *  groupPos array is (13 7 5) and the groupSize array is (2 1 3)
 *  For each group, call mergeTheMergeGroup
 */

void adaptMesh::mergeSmallGradsCurvs(){

    int i,j,k;
    setThetaArray();
    setLargeSmallGradCurv();

    //---------- mark cells with small changes

    mark.clear();
    int iHi = (iUpper < ngrd-1) ? iUpper   : iUpper-1;
    int iLo = (iLower > 0)      ? iLower-1 : iLower;  // iLower is usually cell with  
    for(i=iLo; i<=iHi; i++)                           // eddy edge inside.  When do eddy
        if(testSmallGradAndCurv(i))                   // that cell shrinks so test one cell 
            mark.push_back(i);                        // lower since the test is between i and i+1

    if(mark.size() == 0)
        return;

    //---------- set the merge groups: pos (indx) of start, # of merge cells

    vector<int> groupPos; 
    vector<int> groupSize; 
    
    for(i=mark.size()-1, k=0; i>=0; k++) {             // i is reset inside
        groupPos.push_back(mark[i]);
        groupSize.push_back(1);
        for(j=i-1; j>=0; j--) {
            if((mark[j+1] - mark[j]) == 1)  
                groupSize[k]++; 
            else
                break;
        }
        i = j;
    }

    //---------- operate on each merge group in turn

    for(i=0; i<groupPos.size(); i++)  {
        mergeTheMergeGroup(groupPos[i], groupSize[i], false);
    }

    //---------- update the eddy regions
    
    iLower = anyl->linePositionToIndex(posLower, true);
    iUpper = anyl->linePositionToIndex(posUpper, false);


}

///////////////////////////////////////////////////////////////////////////////

/** Called by mergeSmallGradsCurvs, true if both grad and curv are small.
 *  This indicats a cell to be merged.
 *
 *  @param i input: test i and i+1.
 */
bool adaptMesh::testSmallGradAndCurv(const int &i) {

    int ip = i+1;

    bool LsmallGrad = (fabs((*phi)[ip]-(*phi)[i]) < smallGrad);
    bool LsmallCurv = (fabs(theta[ip] - theta[i]) < smallCurv);
    bool LsamePhase = (fabs((*bdy)[ip]-(*bdy)[i]) < 0.01);

    return (LsmallGrad && LsmallCurv && LsamePhase);

}

///////////////////////////////////////////////////////////////////////////////

/** Fills theta array at each grid point with the slope of the phi profile.
 * Used to compute curv, like phi is used for grad.  
 */
void adaptMesh::setThetaArray() {
   
    theta.resize(ngrd-1);
    for(int i=0, ip=1; i<ngrd-1; i++, ip++)  
        theta[i] = atan( ((*phi)[ip]-(*phi)[i])/(dx[i]) );

}

///////////////////////////////////////////////////////////////////////////////

/** Un-normalize the input file factors with the grid values */
void adaptMesh::setLargeSmallGradCurv(){

    double maxPhi = *max_element((*phi).begin(), (*phi).end());
    double minPhi = *min_element((*phi).begin(), (*phi).end());
    largeGrad     = (maxPhi - minPhi) * odtP->largeGradFrac;
    smallGrad     = (maxPhi - minPhi) * odtP->smallGradFrac;

    double maxTta = *max_element(theta.begin(), theta.end());
    double minTta = *min_element(theta.begin(), theta.end());
    largeCurv     = (maxTta - minTta) * odtP->largeCurvFrac;
    smallCurv     = (maxTta - minTta) * odtP->smallCurvFrac;

}

///////////////////////////////////////////////////////////////////////////////

/** Recursive function called for each merge group.
 *  Pass in index number of beginning "M" of the merge group, and the number of M's
 *  in the group, and also the phi used in computing the scalar difference criteria
 *  If the range of phi in the whole group is less than the threshold we can merge
 *  the whole group.  Otherwise we should only merge part of the group.  In this case,
 *  the position of the max change in phi is not merged, and the two (or one if
 *  the max change in phi is at a boundary of the group) remaining parts 
 *  are merged as separate groups (hence the recursion).  This is again done right to left
 *  so the whole merging of small grads is done right to left.
 *  When merging a whole group, if the resulting cell is too big, we split the group at
 *  some location and do each part (recusive).  Currently, just split in the middle of
 *  the group.  This is okay, but better if cells are evenly spaced.  If cells are not
 *  evenly spaced, a better method would be to sweep from right till get above the large
 *  cell range (to specify ixpos).
 *  LdoAll is a flag: if true then we are merging the whole group (subject only to large cell)
 *  
 *  Later, the curv criteria was added.  Hence to merge a whole group you have to have
 *  a small enough range of grad and curv.  If this does not pass, then if it didn't
 *  pass due only to grad, the split as above based on grad.  If it didn't pass due only
 *  to curve, the split as above based on curv.  If neither condition passed, then split
 *  as above based on grad.
 *
 *  @param mPos input: starting index of the merge group.
 *  @param gSize input:  number of cells in the merge group.
 *  @param LdoAll input: flag true when mergeing the whole group (suject only to large cell limit).
 */
void adaptMesh::mergeTheMergeGroup(int mPos, int gSize, bool LdoAll) { 

    int    ixpos;

    //---------- get the spread of phi in the merge group

    double maxPhi, minPhi, maxDphi;
    double maxTta, minTta, maxCurv;

    if(!LdoAll) {
        maxPhi = *max_element((*phi).begin()+mPos-gSize+1,
                  (*phi).begin()+mPos+1);          // range MMMx (with the x)
        minPhi = *min_element((*phi).begin()+mPos-gSize+1,
                  (*phi).begin()+mPos+1);
        maxDphi = maxPhi - minPhi; 

        maxTta = *max_element(theta.begin()+mPos-gSize+1, theta.begin()+mPos+1);
        minTta = *min_element(theta.begin()+mPos-gSize+1, theta.begin()+mPos+1);
        maxCurv = maxTta - minTta;                
    }

    //---------- test the range

    if(LdoAll || (maxDphi < smallGrad && maxCurv < smallCurv)) {  // merge the whole block

        //--------- test if making too large a cell

        double newCellSize = anyl->posf[mPos+2] - anyl->posf[mPos-gSize+1];

        if(newCellSize > odtP->dxmax ) {        // new cell is too big
            if(gSize == 1)                      // one cell --> don't do
                return;
            else {                              // several cells, split range and do each side
                ixpos = mPos - gSize/2; 
                if(ixpos == mPos)                                 // MMMMx
                    mergeTheMergeGroup(mPos-1, gSize-1, true);
                else if(ixpos == (mPos-gSize+1))                  // xMMMM
                    mergeTheMergeGroup(mPos, gSize-1, true);
                else {                                            // MMxMM
                    int ncells1 = mPos-ixpos;
                    int ncells2 = gSize-ncells1-1;
                    mergeTheMergeGroup(mPos, ncells1, true);
                    mergeTheMergeGroup(mPos-ncells1-1, ncells2, true);
                }
            }
        }

        else {                                  // new cell is not too big, do whole group

            if(gSize == 1)         
                merge2cells(mPos);
            else 
                mergeSeveralCells(mPos-gSize+1, gSize+1);     // MMMx -> gSize=3, mrg 4 cells

        }
    }

    //-----------------------

    else {    //---------- either maxDphi or maxCurv was too big over the domain
              //---------- if both, then maxDphi takes preference (first in the if else below)
              //---------- split block and work on parts

        double dmb=0.0;
        double dmb2;

        if(maxDphi >= smallGrad) {  // Grad case: find the max incremental delta phi
            ixpos=mPos;
            for(int j=mPos; j>mPos-gSize; j--)   {
                dmb2 = fabs((*phi)[j+1]-(*phi)[j]);
                if( dmb2 > dmb) {
                    dmb = dmb2;
                    ixpos = j;
                }
            }
        }
        else {                     // Curv case: find the max incremental delta theta
            ixpos=mPos;
            for(int j=mPos; j>mPos-gSize; j--)   {
                dmb2 = fabs(theta[j+1]-theta[j]);
                if( dmb2 > dmb) {
                    dmb = dmb2;
                    ixpos = j;
                }
            }
        }
        
        //---------- split the original merge group MMMMM

        if(ixpos == mPos)                              // MMMMx
            mergeTheMergeGroup(mPos-1, gSize-1, false);
        else if(ixpos == (mPos-gSize+1))               // xMMMM
            mergeTheMergeGroup(mPos, gSize-1, false);
        else {                                         // MMxMM
            int ncells1 = mPos-ixpos;
            int ncells2 = gSize-ncells1-1;
            mergeTheMergeGroup(mPos, ncells1, false);
            mergeTheMergeGroup(mPos-ncells1-1, ncells2, false);
        }

    }   

}

///////////////////////////////////////////////////////////////////////////////

/** Searches domain till a too-large delta phi (or theta) found between cell i and i+1.
 *  These two cells are both split, then the center
 *  two resulting cells are merged.  Actually, this is done in odtline where
 *  a single new cell is inserted, but the operation is the same.
 *  First populate the mark array and the locations of the two new faces for 
 *  each marked cell.  Then go through and implement the changes.  These are
 *  done in two steps so that all cell changes are independent of other cell 
 *  changes.  This works since the splitting is 1/3 or less.
 *  Multiple passes are done.  On the first pass we just test each cell.  
 *  On the subsequent passes, we only test cells that used to be marked
 *  and the newly created cells (updating the indicies appropriately), see below.
 *  For just one pass, set itmax = 1, and comment the warning.     
 *  phi should be a member of odtline so it shares the same grid and is 
 *  updated with merging and splitting operations
 */
void adaptMesh::splitHighGradsCurvs() {

    int i, j, k;
    int itmax = 20;             // set this to 1 for one pass

    setThetaArray();
    setLargeSmallGradCurv();

    vector<double> newFacesL;      // low  side of common cell face
    vector<double> newFacesH;      // high side of common cell face
    vector<int>    iCheck;         // on pass > 2, these are the cells to check

    //-------------------------------------------------------------------

    for(int it=1; it<=itmax; it++) {    // loop over domain till done 

        if(it==itmax)
            cout << endl << "************* WARNING itmax in splitHighGradsCurvs" << endl;

        mark.clear();                   // reset arrays
        newFacesL.clear();
        newFacesH.clear();

        //---------- Mark offenders, fill the new face positions

        int iHi = (iUpper < ngrd-1) ? iUpper+1 : iUpper;       
        int iLo = (iLower > 0)      ? iLower-1 : iLower;       
        for(i=(it==1 ? iLo : 0) ;; i++) {  //ark

            if(it==1) {
                if(i==iHi)
                    break;
                testCellLargeGradCurv(i, newFacesL, newFacesH);
            }
            else {
                if(i==iCheck.size())
                    break;
                testCellLargeGradCurv(iCheck[i], newFacesL, newFacesH);
            }
        }  

        if(mark.size() == 0)                 // done if no cells marked
            break;

        //---------- if split bounds, move bound face up/down a face

        if(mark[0] == iLo)
            posLower = anyl->posf[iLo];
        if(mark[mark.size()-1] == iHi && iHi < ngrd-1)
            posUpper = anyl->posf[iHi+2];


        //---------- Split and merge the offending cells, if any

        for(i=mark.size()-1; i>=0; i--)     // reverse: "faster" insert/delete & no need update mark
            split2mergeMiddle(mark[i], newFacesL[i], newFacesH[i]);

        //---------- Set the iCheck array for the next pass

        iCheck.resize(mark.size()*2);                 // consider:  xMMxMx, mark = (1 2 4)
        for(j=0, k=0; j<iCheck.size(); j+=2, k++) {   // becomes:   xM'nM'nxM'nx  (primes are old Ms)
            iCheck[j]   = mark[k] + k;                // with iCheck = (1 2 3 4 6 7) is two parts:
            iCheck[j+1] = iCheck[j]+1;                // an M' part (1 3 6) and that +1 (2 4 7)
        }

        //---------- Fix the grid size

        ngrd  += mark.size();
        ngrdf += mark.size();

    }   //---------- end loop till done

    //---------- update the eddy regions
    
    iLower = anyl->linePositionToIndex(posLower, true);
    iUpper = anyl->linePositionToIndex(posUpper, false);

}

///////////////////////////////////////////////////////////////////////////////

/** Split two cells into 4 and merge the middle two to make three.
 *
 *  @param i input: first of two cell indicies.
 *  @param f1 input: lower of two new cell faces.
 *  @param f1 input: upper of two new cell faces.
 */
void adaptMesh::split2mergeMiddle(int i, double f1, double f2) {

    int ip  = i+1;
    int ipp = ip+1;
    dx[i]   = f1 - anyl->posf[i];
    dx[ip]  = anyl->posf[ipp] - f2;
    dx.insert(dx.begin()+ip, f2-f1);

    //anyl->adptVar.insert(anyl->adptVar.begin()+ip, 
    //        0.5*(anyl->adptVar[i]+anyl->adptVar[ip]));

    anyl->split2mergeMiddle(i, f1, f2);
    
    theta.insert(theta.begin()+ip, 0.0);
    theta[i] = atan( ((*phi)[ip]-(*phi)[i])/(dx[i]) );
    i++; ip++;
    theta[i] = atan( ((*phi)[ip]-(*phi)[i])/(dx[i]) );
    i++; ip++;
    theta[i] = atan( ((*phi)[ip]-(*phi)[i])/(dx[i]) );

}


///////////////////////////////////////////////////////////////////////////////

/** Test for large delta phi or theta and return true if either condition is met.
 *
 *  @param i input: test this cell index and the next.
 *  @param newFacesL input: stores the low faces of new cells.
 *  @param newFacesH input: stores the high faces of new cells.
 *  @return true to mark a deviant cell, false otherwise.
 */
bool adaptMesh::testCellLargeGradCurv(int i, std::vector<double> &newFacesL,
                                             std::vector<double> &newFacesH) {


    int    ip = i+1;
    double d1;                             // delta on smaller cell     
    double d2;                             // delta on larger  cell

    //--------------------

    if( fabs( (*bdy)[ip]-(*bdy)[i] ) > 0.01 )
        return false;                      // don't mark if i,ip are diff phases

    //--------------------

    if( fabs((*phi)[ip]-(*phi)[i]) > largeGrad    || 
        fabs(theta[ip]-theta[i])   > largeCurv )     {

        if(dx[i] > dx[ip]) {               //   |              : d2 | d1 :     |
            d1 = dx[ip] / 3.0;
            if(d1 < odtP->dxmin)           // don't mark cell if splitting is too small
                return false;
            d2 = (dx[i] > 2.0*dx[ip]) ? 2.0*d1 : dx[i]/3.0;           
            // d2 = d1;                
            mark.push_back(i);
            newFacesL.push_back( anyl->posf[ip] - d2 );
            newFacesH.push_back( anyl->posf[ip] + d1);
        }
        else {                             //  |    : d1 |  d2 :               |
            d1 = dx[i] / 3.0;
            if(d1 < odtP->dxmin)           // don't mark cell if splitting is too small
                return false;
            d2 = (dx[ip] > 2.0*dx[i]) ? 2.0*d1 : dx[ip]/3.0;
            // d2 = d1;
            mark.push_back(i);
            newFacesL.push_back( anyl->posf[ip] - d1 );
            newFacesH.push_back( anyl->posf[ip] + d2 );
        }
        return true;

    }       

    //--------------------
    
    else
        return false;

}

///////////////////////////////////////////////////////////////////////////////
/** Rule: adjacent cells should have size ratio at or below 2 point 5.
 *  Alternately, above 0.4=1/2.5.
 *  Impose the rule entirely through cell splitting
 *  This should not create "small" cells if there are none initially
 *  Mark cells that offend their higher (index) neighbor in ratio.
 *  Order of operation is not important.
 */   

void adaptMesh::impose2point5rule(){


    int    i;
    double d1;

    //---------- set the mark array with offending cells

    mark.clear();
    int iHi = (iUpper < ngrd-1) ? iUpper   : iUpper-1;
    int iLo = (iLower > 0)      ? iLower-1 : iLower;    
    for(i=iLo; i<=iHi; i++) {                      
        d1 = dx[i]/dx[i+1];
        if(d1 > 2.5 || d1 < 0.4)
            mark.push_back(i);
    }
    i = ngrd-1;
    if(odtP->Lperiodic && iUpper==i) {
        d1 = dx[i]/dx[0];
        if(d1 > 2.5 || d1 < 0.4)
            mark.push_back(i);
    }

    //-------- loop over each marked cell and fix the 2.5 offenders

    for(i=0; i<mark.size(); i++)        
        fix2point5offender(mark[i], i);   

}

///////////////////////////////////////////////////////////////////////////////

/** 
 *
 * @param mPos input,  marks a cell that offends its next neighbor with respect to the 2.5 rule.
 * @param iglobal input, is which loop through the mark arrary, for the mark array update.
 *       (Could just leave this out and do all of em but only need
 *       to update subsequent ones).
 *
 *           Routine is recursive.  Returns if the test is passed, or if we are at
 *                the ends of the domain.                                                \n 
 *           If start with no "small cells" routine won't create any small cells
 *           Order of operations doesn't matter\n.
 *           Find the larger of mPos and its next neighbor (mPos+1) and split that
 *                cell on the side of the smaller cell.  Split it nsplit times in half.  \n
 *                So, |               ||  ==>  |   *   :    :   ||  when splitting twice.\n
 *           Then go to the opposite side of the split cell (marked with * above) and
 *                compare to its neighbor on the other side.  In this example, we would
 *                "mark" the cell before the * and call the same routine on it.          \n
 *           Hence, we can traverse through the domain.  Generally you keep traversing 
 *                till satisfy the rule or hit the edge.  To keep going in one direction
 *                the cells need to keep increasing (so we won't go too far since motion
 *                implies geometric growth).  You also will stop traversing when you run into
 *                a smaller cell.                                                        \n
 *           Consider:  ||        |            ||            ||                                  |   \n
 *                       0    1          2     3       4     5                  6                    \n
 *           mark offenders: 0 2 3 4 5                                                               \n
 *           Start at 0:                                                                             \n
 *           0 vs 1 --> split 1 once                                                                 \n
 *                      ||    :   |            ||            ||                                  |   \n
 *                       0  1   2        3     4       5     6                  7                    \n
 *           2 vs 3 --> split 3 once                                                                 \n
 *                      ||    :   |      :     ||            ||                                  |   \n
 *                       0  1   2     3     4  5       6     7                  8                    \n
 *           4 vs 5 --> split 4 once                                                                 \n
 *                      ||    :   |      :  :  ||            ||                                  |   \n
 *                       0  1   2     3   4  5 6       7     8                  9                    \n
 *           3 vs 4 --> pass --> done                                                                \n
 *           now do next in mark array (which was updated as we went to ( X 3 6 7 8)                 \n
 *           Start at 3:                           \n
 *           3 vs 4 --> pass (trivially) --> done  \n
 *           Start at 6:                           \n
 *           6 vs 7 --> split 7 once               \n
 *                      ||    :   |      :  :  ||      :     ||                                  |   \n
 *                       0  1   2     3   4  5 6   7      8  9                  10                   \n
 *           8 vs 9 --> pass (say) --> done:  mark array ( X X X 7 9 )                               \n
 *           Start at 7:                           \n
 *           7 vs 8 --> pass                       \n
 *           Start at 9:                           \n
 *           9 vs 10 --> split 4 times             \n
 *                      ||    :   |      :  :  ||      :     || :  :    :       :                |   \n
 *                       0  1   2     3   4  5 6   7      8  9 10 11 12    13           14           \n
 *           14 at the end --> DONE
 */

void adaptMesh::fix2point5offender(int mPos, const int &iglobal) {


    //--------- Simply return if you pass the test

    int ip = (mPos == ngrd-1) ? 0 : mPos+1;
    double ratio = (dx[mPos] < dx[ip]) ? dx[ip]/dx[mPos] : dx[mPos]/dx[ip];
    if(ratio < 2.5)
        return;

    //--------- Split the larger of the two cells

    int     i;
    int     isplt = (dx[mPos] < dx[ip]) ? ip : mPos;          // split larger of 2 cells 
    int     nsplt = static_cast<int>(log2(ratio / 2.5)) + 1 ; // how many splits to do

    vector<double> icp(nsplt);                 // pos of new intrnl cell fcs (rel to lft edge)

    bool splitCellOnRight = (isplt > mPos);
    if(mPos == ngrd-1 && isplt == 0)           // for periodic
        splitCellOnRight = true;

    if(splitCellOnRight) {                     // | |  :  :    :        |  --> nsplt=3
        icp[nsplt-1] = dx[isplt]*0.5;
        for(i=nsplt-2; i>=0; i--)
            icp[i] = icp[i+1]*0.5;

        anyl->splitCell(isplt, nsplt, icp, true); 

        for(i=nsplt-1; i>=1; i--)
            icp[i] -= icp[i-1];
        dx[isplt] *= 0.5;                      // icp was positions, now are dx's
        dx.insert(dx.begin()+isplt, icp.begin(), icp.end());

        //anyl->adptVar.insert(anyl->adptVar.begin()+isplt, nsplt, anyl->adptVar[isplt]);
        //interpAdtpVar2p5(isplt, isplt+nsplt);
    }
    else {                                     // |        :    :  :  | |   --> nsplt=3
        icp[0] = dx[isplt]*0.5;                
        for(i=1; i<nsplt; i++)                 // set icp as dx's : 1/2, 1/4, 1/8 ...
            icp[i] = icp[i-1]*0.5;
        for(i=1; i<nsplt; i++)                 // now offset to 0.5, 0.75, 0.876 ...
            icp[i] += icp[i-1];

        anyl->splitCell(isplt, nsplt, icp, true);    
        
        for(i=0; i<nsplt-1; i++)               // update dx arr, reuse icp arr
            icp[i] = icp[i+1] - icp[i];
        if(nsplt >=2) 
            icp[nsplt-1] = icp[nsplt-2];
        dx[isplt] *= 0.5;
        dx.insert(dx.begin()+isplt+1, icp.begin(), icp.end());

        //anyl->adptVar.insert(anyl->adptVar.begin()+isplt, nsplt, anyl->adptVar[isplt]);
        //interpAdtpVar2p5(isplt, isplt+nsplt);
    }

    ngrd  += nsplt;                            // update adaptMesh's ngrd, ngrdf (odtl's are done)
    ngrdf += nsplt;

    //--------- Update the mark array

    for(i=iglobal+1; i<mark.size(); i++)
        if(mark[i] > isplt)
            mark[i] += nsplt;

    //--------- Now compare the other half of the split cell with neighbor

    int inext;
    if(splitCellOnRight) {
        inext = isplt + nsplt;
        if(inext == ngrd-1 && !odtP->Lperiodic)
            return;
    }
    else {
        inext = mPos-1;
        if(inext == -1) {
            if(!odtP->Lperiodic)
                return;
            else
                inext = ngrd-1;
        }
    }

    fix2point5offender(inext, iglobal);                 // recursive call 

}

///////////////////////////////////////////////////////////////////////////////
   
/** Split any cells larger than the limit.
*  Not really needed, except maybe once at the very start.  The odt solution and
*  mesh adaptation will not create large cells to be split.  The initial condition
*  should be set up with enough cells to not violate the condition.  That is,
*  the user should be consistent in the specification of domain size, ncells, and
*  large cell size.
*  The user should ensure that the large limit is at least twice the small limit
*/
void adaptMesh::splitLargeCells() {
 
    int i, it;
    int itmax = 10;
    vector<double> icp(1);
    
    for(it=1; it<=itmax; it++) {

        mark.clear();
        for(i=0; i<ngrd-1; i++) 
            if(dx[i] > odtP->dxmax) 
                mark.push_back(i);
        if(mark.size()==0)
            break;

        for(i=mark.size()-1; i>=0; i--) {
            icp[0] = dx[i] * 0.5; 
            anyl->splitCell(i, 1, icp, true);
            //anyl->adptVar.insert(anyl->adptVar.begin()+i,anyl->adptVar[i]);
            dx[i] *= 0.5;
            dx.insert(dx.begin()+i, dx[i]*0.5);
        }

        //---------- Fix the grid size

        ngrd  += mark.size();
        ngrdf += mark.size();

        if(it==itmax)
            cout << endl << "*** MAX iter reached in split large cells" << endl;
    }

}

///////////////////////////////////////////////////////////////////////////////

/** Set cell size array based on grid cell positions
*/

void adaptMesh::setDxArray() {

    dx.resize(ngrd);
    for(int i=0, ip=1; i<ngrd; i++, ip++)
        dx[i] = anyl->posf[ip] - anyl->posf[i];

}

///////////////////////////////////////////////////////////////////////////////

/** Interpolates the adapt variable for the 2.5 rule.
 *  Assumes adptVar from is to ie is uniform, with the initial value before split.
 */

void adaptMesh::interpAdtpVar2p5(int is, int ie) {

    double xmid = 0.5*(anyl->posf[is] + anyl->posf[ie+1]);
    double ymid = anyl->adptVar[is];
    double y1, y2, x1, x2;

    if(is == 0) {                              // splitting first cell
        for(int i=is+1; i<=ie; i++) {
            if(anyl->pos[i] <= xmid) {         // split on left half of cell: no interp
                continue;
            }
            else {                             // split on right half: interp
                x1 = xmid;
                x2 = anyl->pos[ie+1];
                y1 = ymid;
                y2 = anyl->adptVar[ie+1];
                anyl->adptVar[i] = y1 + (y2-y1)/(x2-x1)*(anyl->pos[i]-x1);
            }
        }
    }
    else if(ie == anyl->ngrd-1) {              // splitting last cell
        for(int i=is; i<ie; i++) {
            if(anyl->pos[i] >= xmid) {         // split on right half of cell: no interp
                continue;
            }
            else {                             // split on left half: interp
                x1 = anyl->pos[is-1];
                x2 = xmid;
                y1 = anyl->adptVar[is-1];
                y2 = ymid;
                anyl->adptVar[i] = y1 + (y2-y1)/(x2-x1)*(anyl->pos[i]-x1);
            }
        }
    }
    else {                                     // splitting interior cells
        for(int i=is; i<=ie; i++) {
            if(anyl->pos[i] <= xmid) {
                x1 = anyl->pos[is-1];
                x2 = xmid;
                y1 = anyl->adptVar[is-1];
                y2 = ymid;
            }
            else {
                x1 = xmid;
                x2 = anyl->pos[ie+1];
                y1 = ymid;
                y2 = anyl->adptVar[ie+1];
            }
            anyl->adptVar[i] = y1 + (x1==x2) ? 0 : (y2-y1)/(x2-x1)*(anyl->pos[i]-x1);
        }
    }

}

///////////////////////////////////////////////////////////////////////////////


























